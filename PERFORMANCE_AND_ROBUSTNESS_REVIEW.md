# パフォーマンス・堅牢性評価レポート

## 評価対象
- **システム規模**: 生徒300人、受験校データ約4,500件（300人 × 15校）、大学コード6万件
- **プラットフォーム**: Google Apps Script (GAS) + Google Spreadsheet
- **評価日**: 2025年12月

---

## 🔴 重大な問題（即座に対応が必要）

### 1. 大学データ（6万件）の全件取得によるパフォーマンス問題

**問題箇所**: 
- `main.js:248-257` (`getUniversityDataList`)
- `main.js:733-757` (`getUniversityDataApi`)
- `script.html:342-401` (クライアント側での処理)

**問題点**:
- 6万件の大学データを一度に取得・送信している
- JSON文字列として全件をクライアントに送信（約数MBのデータ転送）
- クライアント側で全件をメモリに保持し、検索時に全件フィルタリング
- 初回ロード時に数秒〜数十秒の待機時間が発生する可能性

**影響**:
- 初回アクセス時のユーザー体験が悪化
- モバイル環境でのデータ転送コスト増大
- ブラウザのメモリ消費増大（特に低スペック端末）
- localStorageへの保存時に容量制限に達する可能性（約5-10MB）

**推奨改善策**:
1. **サーバーサイド検索APIの実装**: クライアントから検索キーワードを送信し、サーバー側でフィルタリングして結果のみ返す
2. **ページネーション**: 検索結果を50件ずつ返す（既存の`displayStep`を活用）
3. **インデックス化**: 大学コードをキーとしたMapをサーバー側で事前構築し、コード検索を高速化
4. **キャッシュ戦略の見直し**: 全件ではなく、よく使われるデータのみキャッシュ

**実装例**:
```javascript
// サーバー側: 検索APIの追加
function searchUniversityData(keyword, offset = 0, limit = 50) {
  const universitySheet = activeSpreadsheet.getSheetByName(SHEET_NAMES.DAIGAKU);
  // キーワードでフィルタリング（Sheets APIのフィルタ機能を活用）
  // または事前にインデックス化されたデータから検索
  // 結果をoffset/limitでページネーション
  return JSON.stringify(filteredResults);
}
```

---

### 2. 受験データ保存時の全データ取得によるパフォーマンス問題

**問題箇所**: `main.js:316` (`saveExamDataList`)

**問題点**:
- 保存時に受験校DBの全データ（約4,500件 + 論理削除分）を取得
- 1人の生徒のデータ（平均15件）を保存するために全データを読み込む
- データ量が増えるほど処理時間が線形に増加

**影響**:
- 保存処理が遅延（現在は許容範囲だが、将来的に問題化）
- 同時アクセス時のメモリ消費増大
- GASの実行時間制限（6分）に近づく可能性

**推奨改善策**:
1. **条件付きデータ取得**: 対象ユーザーのデータのみを取得
   ```javascript
   // Sheets APIのフィルタ機能を使用
   const filterCriteria = {
     filterSpecs: [{
       columnIndex: EXAM_DATA.MAIL_ADDR,
       filterCriteria: {
         condition: {
           type: 'TEXT_EQ',
           values: [{ userValue: mailAddr }]
         }
       }
     }]
   };
   ```
2. **バッチ処理の最適化**: 更新が必要な行のみを特定して更新

---

### 3. ロック待機時間と同時アクセス時の競合リスク

**問題箇所**: `main.js:287-294` (`saveExamDataList`)

**問題点**:
- ロック待機時間が10秒と長い（`tryLock(10000)`）
- ロック取得失敗時に即座にエラーを返すため、リトライ機構がない
- 同時に複数のユーザーが保存操作を行うと、後続ユーザーが待たされる

**影響**:
- ピーク時間帯（受験シーズン）の同時アクセス時に保存失敗が多発
- ユーザーが手動でリトライする必要がある
- データの不整合リスク

**推奨改善策**:
1. **指数バックオフによるリトライ**: 自動リトライ機構の実装
2. **ロック待機時間の最適化**: 待機時間を短縮し、リトライ回数を増やす
3. **楽観的ロック**: タイムスタンプベースの楽観的ロックを検討

**実装例**:
```javascript
function saveExamDataListWithRetry(strJuken, mailAddr, retryCount = 0) {
  const MAX_RETRIES = 3;
  const LOCK_TIMEOUT = 5000; // 5秒に短縮
  
  try {
    const lock = LockService.getDocumentLock();
    const hasLock = lock.tryLock(LOCK_TIMEOUT);
    
    if (!hasLock) {
      if (retryCount < MAX_RETRIES) {
        Utilities.sleep(1000 * (retryCount + 1)); // 指数バックオフ
        return saveExamDataListWithRetry(strJuken, mailAddr, retryCount + 1);
      }
      throw new Error('他のユーザーが編集中です。少し待ってから再度お試しください。');
    }
    // ... 保存処理
  } catch (e) {
    // エラーハンドリング
  }
}
```

---

## 🟡 中程度の問題（早期に対応推奨）

### 4. エラーハンドリングの不十分さ

**問題箇所**: 
- `main.js:225-229` (`getInitialData`)
- `main.js:410-419` (`saveExamDataList`)
- その他多数の関数

**問題点**:
- エラーメッセージが「作成者に連絡してください」と汎用的
- エラーの種類に応じた適切な処理が不足
- ログ出力が不十分（`console.log`のみ、Stackdriver Logging未活用）

**推奨改善策**:
1. **エラー分類**: ネットワークエラー、権限エラー、データ整合性エラーなどに分類
2. **詳細ログ**: エラー発生時のコンテキスト情報（ユーザー、操作内容、データ状態）を記録
3. **ユーザーフレンドリーなメッセージ**: エラーの種類に応じた具体的なメッセージを表示

---

### 5. データ整合性チェックの不足

**問題箇所**: `main.js:689-707` (`validateInputData`)

**問題点**:
- 大学コードの存在チェックがクライアント側のみ
- サーバー側での再検証がない
- 重複チェックがクライアント側のみ（`script.html:597-610`）
- タイムスタンプの整合性チェックがない

**推奨改善策**:
1. **サーバー側での再検証**: クライアント側のバリデーションに加えて、サーバー側でも検証
2. **大学コードの存在確認**: 保存時に大学コードがマスタに存在するか確認
3. **重複チェックの強化**: サーバー側でも重複をチェック

---

### 6. メモリ効率の問題

**問題箇所**: 
- `script.html:395-397` (大学データのMap化)
- `main.js:321-332` (既存データのMap化)

**問題点**:
- 6万件の大学データをMapとしてメモリに保持
- 受験データ保存時に全データを配列として保持

**推奨改善策**:
1. **必要時のみロード**: 検索時のみデータを取得
2. **データ構造の最適化**: 必要な情報のみを保持

---

## 🟢 軽微な問題（改善の余地あり）

### 7. クライアント側の検索処理の最適化

**問題箇所**: `script.html:778-846` (`searchKeyword`)

**問題点**:
- デバウンス処理は実装されているが、全件フィルタリングのコストが高い
- 検索結果の表示が50件ずつだが、フィルタリングは全件に対して実行

**推奨改善策**:
- サーバーサイド検索への移行（上記1と統合）

---

### 8. PDF生成処理の最適化

**問題箇所**: `main.js:570-656` (`sendPdf`)

**問題点**:
- 一時スプレッドシートを作成してPDF化（処理が重い）
- エラー時の一時ファイル削除が不完全な可能性

**推奨改善策**:
1. **エラーハンドリングの強化**: 一時ファイル削除の確実性向上
2. **非同期処理の検討**: PDF生成を非同期で実行（ただしGASの制約あり）

---

### 9. キャッシュ戦略の改善

**問題箇所**: `script.html:342-393` (`getUniversityDataList`)

**問題点**:
- localStorageの容量制限（通常5-10MB）を考慮していない
- キャッシュの無効化機構がない（管理者がデータ更新した場合）

**推奨改善策**:
1. **キャッシュサイズの制限**: 必要最小限のデータのみキャッシュ
2. **バージョン管理**: データのバージョン番号を管理し、更新時にキャッシュを無効化

---

## 📊 パフォーマンス指標の推奨

### 現在の推定パフォーマンス

| 操作 | 推定時間 | 問題点 |
|:---|:---|:---|
| 初回ロード（大学データ含む） | 5-15秒 | 6万件のデータ転送 |
| 受験データ保存 | 2-5秒 | 全データ取得 |
| 大学検索 | 0.5-2秒 | クライアント側全件フィルタリング |
| PDF生成 | 3-10秒 | 一時ファイル作成・変換 |

### 改善後の目標

| 操作 | 目標時間 | 改善策 |
|:---|:---|:---|
| 初回ロード | 1-3秒 | サーバーサイド検索への移行 |
| 受験データ保存 | 1-2秒 | 条件付きデータ取得 |
| 大学検索 | 0.3-0.8秒 | サーバーサイド検索 |
| PDF生成 | 3-10秒 | 現状維持（GASの制約） |

---

## 🔒 堅牢性の改善提案

### 1. トランザクション処理の強化

**現状**: ロック機構は実装されているが、部分的な失敗時のロールバックがない

**推奨**: 
- 変更前の状態をバックアップ
- エラー発生時にロールバック
- または、変更をバッチで適用し、すべて成功した場合のみコミット

### 2. データバックアップ

**現状**: バックアップ機構がない

**推奨**:
- 定期的なデータエクスポート機能
- 変更履歴の記録（監査ログ）

### 3. 入力値のサニタイゼーション

**現状**: 基本的なバリデーションはあるが、XSS対策などが不十分

**推奨**:
- HTMLエスケープ処理の強化
- SQLインジェクション対策（GASでは不要だが、データ検証は重要）

---

## 🎯 優先順位付き改善計画

### Phase 1: 緊急対応（1-2週間）
1. ✅ 大学データのサーバーサイド検索API実装
2. ✅ ロック待機時間の最適化とリトライ機構
3. ✅ エラーハンドリングの改善

### Phase 2: 重要改善（1ヶ月）
4. ✅ 受験データ保存時の条件付き取得
5. ✅ データ整合性チェックの強化
6. ✅ キャッシュ戦略の見直し

### Phase 3: 最適化（2-3ヶ月）
7. ✅ メモリ効率の改善
8. ✅ パフォーマンス監視の導入
9. ✅ バックアップ機構の実装

---

## 📝 まとめ

### 主な課題
1. **6万件の大学データ全件取得**が最大のボトルネック
2. **同時アクセス時の競合**が発生しやすい
3. **エラーハンドリング**が不十分

### 推奨される改善
1. **サーバーサイド検索API**の実装（最優先）
2. **ロック機構の改善**とリトライ機構
3. **条件付きデータ取得**によるパフォーマンス向上

### 期待される効果
- 初回ロード時間: **5-15秒 → 1-3秒**（約80%改善）
- 保存処理時間: **2-5秒 → 1-2秒**（約50%改善）
- 同時アクセス時のエラー率: **高 → 低**（リトライ機構により）

---

**評価者**: AI Code Reviewer  
**評価日**: 2025年12月  
**次回レビュー推奨日**: 改善実装後1ヶ月

